// OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진
// 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만,
// 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다.
// 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은
// 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.

// 예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.
// 아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.

// 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.
// 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.
// 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.
// 위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.

// 제한 사항
// 숫자 N: 1 이상 10억 이하의 자연수
// 숫자 K: 1 이상의 자연수
// 입출력 예
// N	result
// 5	2
// 6	2
// 5000	5
// 입출력 예 설명
// 입출력 예 #1
// 위의 예시와 같습니다.

// 입출력 예 #2
// 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다.
// 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다.
// 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.

// 입출력 예 #3
// 위와 같은 방식으로 합니다.

// n은 1이상이며 기본적으로 순간이동을 하기위해선 최소 1칸의 점프가 필요하기 때문에 count의 기본값을 1로 할당한다.
// 0 부터 카운트 하는 방법을 생각하긴 힘들다.
// 7로 가기위해선
// 점프(+1) 점프(+1) 순간이동(x2) 점프(+1)
// 점프(+1) 순간이동(x2) 점프(+1) 순간이동(x2) 점프(+1)
// 같이 여러 방법이 있고 n의 값이 클 때, 전체 경우의 수를 찾아 최소값을 찾는것은 비효율적이라고 생각했다.
// 목표값에서 거꾸로 -1, *(1/2)씩 경우의 수를 찾아간다면?
// ex) 2022 는 1011에서 순간이동을 하면 건전지 소모없이 1011칸을 전진할 수 있다.
// 1011은 1010에서 점프 한번을 하면 되고, 1010은 505에서 순간이동하면 건전지 소모없이 505칸을 전진할 수 있다.
// 즉, n이 홀수라면 뒤로점프(건전지 소모 1)를 해주고, 뒤로 순간이동을 해준다. 짝수라면 바로 뒤로 순간이동을 해준다.
// 1번칸에 도달할 때가지 반복한다.

function solution(n) {
  let count = 1;

  const isOddNum = (num) => {
    return !!(num % 2);
  };

  while (true) {
    if (n === 1) return count;
    if (isOddNum(n)) {
      n--;
      count++;
    }
    n = n / 2;
  }
  // 비슷한 방식으로 2진법으로 접근해 해결하는 방법도 있다.
  // return n.toString(2).replace(/0/g, "").length;
}
