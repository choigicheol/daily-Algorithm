// 2개 이하로 다른 비트
// 문제 설명
// 양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.

// x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
// 예를 들어,

// f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
// 수	 비트	        다른 비트의 개수
// 2	000...0010
// 3	000...0011	1

// f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
// 수	 비트	        다른 비트의 개수
// 7	000...0111
// 8	000...1000	4
// 9	000...1001	3
// 10	000...1010	3
// 11	000...1011	2
// 정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

// 제한사항
// 1 ≤ numbers의 길이 ≤ 100,000
// 0 ≤ numbers의 모든 수 ≤ 10^15
// 입출력 예
// numbers	result
// [2,7]	[3,11]
// 입출력 예 설명
// 입출력 예 #1

// 문제 예시와 같습니다.

// ---------------------------------------------------------------------------------------------------- //

// numbers의 모든 수는 0~10^15 범위이기 때문에 +1 씩 더해가며 2진수로 변환 후 자리수를 비교하면 시간초과로 풀 수 없었다.

// 2진수의 뒷자리에 1이 몇번 반복되는지 먼저 파악한다. 그에따라 number+1을 2진수로 변환 했을 때 몇자리의 비트가 달라지는지 알 수 있다.
// 0000 => 0001, 0001 => 0010, 0011 => 0100, 0111 => 1000
// 연속된 1이 없다면 + 1 했을 때 한자리의 비트만 달라진다, 1이 한개라면 두자리, 1이 두개라면 세자리, 1이 세개라면 네자리...

// number를 2진수로 변환 후, 보기 쉽게 reverse하여 0번째 인덱스부터 1이 몇번 반복되는지 count 한다.
// 해당 number에서 +1하면 count +1 만큼 비트 수가 달라지기 때문에
// count가 2이상이라면 count-2 번만큼 (number + 1)에 각각 2^0, 2^1, 2^2... 을 더해 준다.
// 위 값을 전부 더한 값이 x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수 이다.

function solution(numbers) {
  let answer = [];

  // 반전된 2진수를 return하는 함수
  const getReverseBinaryNum = (num) => {
    return num.toString(2).split("").reverse();
  };

  numbers.map((num) => {
    const binaryNum = getReverseBinaryNum(num);
    let count = 0;

    // 2진수의 뒷자리에 1이 몇번 반복되는지 파악
    for (let i = 0; i < binaryNum.length; i++) {
      if (!!Number(binaryNum[i])) count++;
      else break;
    }

    let sum = 1;
    let i = 0;
    while (count - i >= 2) {
      sum += Math.pow(2, i);
      i++;
    }

    answer.push(num + sum);
  });
  return answer;
}
