// 단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 "ba", "na", "n", "a" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요.

// 제한사항
// strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다.
// strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다.
// 사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다.
// t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다.
// 모든 문자열은 알파벳 소문자로만 이루어져 있습니다.
// 입출력 예
// strs	t	result
// ["ba","na","n","a"]	"banana"	3
// ["app","ap","p","l","e","ple","pp"]	"apple"	2
// ["ba","an","nan","ban","n"]	"banana"	-1
// 입출력 예 설명
// 입출력 예 #1
// 문제의 예시와 같습니다.

// 입출력 예 #2
// "ap" 1개, "ple" 1개의 총 2개로 "apple"을 만들 수 있으므로 필요한 단어 개수의 최솟값은 2를 return 합니다.

// 입출력 예 #3
// 주어진 단어로는 "banana"를 만들 수 없으므로 -1을 return 합니다.

// 이전과 마찬가지로 dp로 해결이 가능한 문제이다.

// 작은 문제부터 확인해본다.
// t를 앞에서 부터 늘려가며 strs 내부에 뒷문자열과 일치하는 단어가 있는지 찾는다.
// 앞글자부터 단어장에서 일치하는 단어를 찾아 나가다보면 마지막에 남은 문자열이 strs에서 조합할 수 없는 단어가 나올 수 있다.
// 여기서 string.prototype.endsWith(searchString) 이라는 메서드를 사용한다.
// endsWith 메서드는 어떤 문자열에서 특정 문자열로 끝나는지를 확인할 수 있으며, 그 결과를 true 혹은 false로 반환한다.

/*
// ["ba","na","n","a"]	"banana"
// 1단계
"b"를 만들수 있는건? x

// 2단계
"ba"를 만들수 있는건?
     => "a"가 있나? (1) => "b"가 있나? x
     => "ba"가 있나? (1)
// 3단계
"ban"을 만들수 있는건?
     => "n"이 있나? (1) => "ba"를 만들는 방법은? 2단계 검사 반복
     => "an"이 있나? x
     => "ban"이 있나? x
"bana"를 만들 수 있는건?
     => "a"가 있나? (1) => "ban"을 만들수 있는 방법은? 3단계 검사 반복
     => "na"가 있나? (1) => "ba"를 만들 수 있는 방법은? 2단계 검사 반복
     => "ana"가 있나? x
     => "bana"가 있나? x

여기까지만 봐도 중복되는 검사가 많은 것을 확인할 수 있다.
3단계에서 n단어가 존재하고 ba를 만드는 단어의 수가 저장되어있다면 "ban"을 만드는 단어 수는 (ba를 만드는 단어 수 +1) 로 나타 낼 수 있을 것이다.
 */

// dp 배열을 만들어 준다. 단계에 따른 최소 단어 수를 저장한다.
// 인덱스 값과 단계를 맞추기 위해 t.length +1 만큼의 만들어 0번째 인덱스는 더미로 사용하고
// 배열은 각 단계의 여러가지의 경우의 수 중 Math.min()을 이용해 최소의 방법만을 저장할 것이기 때문에 Infinity로 채워 넣는다.
// for문을 통해 t.length 만큼 순회하며 검사할 단어를 하나씩 늘려간다.
// 중복루프로 strs 배열을 순회하며 감사할 문자열의 뒷부분으로 끝나는 문자열이 있는지 확인한다.
// 있다면, 검사할 단어의 length - 찾은 단어의 length 값을 구한다.
// 위 값이 0이라면 검사할 단어자체가 strs에 존재한다는 것이고 i 단계의 문자열을 구성하는 방법의 최소값이 1이 되는 것이다.
// 위 값이 0이 아니라면 찾은 단어를 제외한 앞부분의 단어를 구성하는 가지수에 +1 한 값이 target 문자열을 구성하는 수가 될 것이다.
// 그렇지만 "bana" 같은 경우 "ba","na", "ba","n","a" 같이 여러가지의 경우의 수가 존재한다.
// 그렇기 때문에 검사하는 문자열이 한가지 단어로 완성되지 않는 경우 여러가지 경우가 있을 수 있기 때문에 그중에 최소값을 저장하기 위해
// dp[i]에는 Math.min(dp[i], dp[diff]+1)을 저장한다. 이미 저장된 값이 더 작다면 더 많은 단어를 이용해 만든는 경우는 저장되지 않을 것이고
// 저장된 값보다 더 적은 단어로 단어를 만들 수 있는 방법이 있다면 해당 방법이 저장 될 것이다.
// 그렇게 dp의 마지막 인덱스 값에 최소 경우의 수가 저장되게 된다. 해당값이 Infinity라면 단어를 구성하는 방법이 없는것이기 때문에 -1을 리턴한다.

function solution(strs, t) {
  const len = t.length;
  const dp = new Array(len + 1).fill(Infinity);

  for (let i = 1; i <= len; i++) {
    const targetStr = t.slice(0, i);

    for (let str of strs) {
      if (targetStr.endsWith(str)) {
        const diff = targetStr.length - str.length;

        if (!diff) dp[i] = 1;
        else dp[i] = Math.min(dp[i], dp[diff] + 1);
      }
    }
  }
  return dp[len] === Infinity ? -1 : dp[len];
}
